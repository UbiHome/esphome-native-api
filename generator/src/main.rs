use octocrab::Octocrab;
use std::fs::{self, File, OpenOptions};
use std::io::{Read, Seek, Write};
use std::path::Path;
use std::env;
const current_version: &str = "2025.6.3";
const last_supplied_version: &str = "2025.2.1";

fn get_package_name(version: &str) -> String {
    format!("version_{}", version.clone()).replace(".", "_")
}

#[tokio::main]
async fn main() {
    
    let mut octocrab: Octocrab = (*octocrab::instance()).clone();
    if env::var("GITHUB_TOKEN").is_ok() {
        println!("Using token");
        let token = env::var("GITHUB_TOKEN").unwrap();
        octocrab = octocrab.user_access_token(token).unwrap();
    }


    let page = octocrab
        .repos("esphome", "esphome")
        .releases()
        .list()
        .per_page(50)
        .send()
        .await
        .unwrap();

    let root_output_dir = "../src/proto";
    let mut mod_file_content = "// This file is @generated by the generator.\n".to_string();
    let mut versions: Vec<String> = Vec::new();

    for release in &page {
        if release.tag_name.contains("b"){
            println!("Skipping {}", &release.tag_name);
            continue;
        }
        // Only till this release:
        if &release.tag_name == last_supplied_version {
            break;
        }


        println!("{}", &release.tag_name);
        let dir = format!("protos/{}", release.tag_name);
        let protos_dir = Path::new(dir.as_str());
        fs::create_dir_all(protos_dir).unwrap();

        let api_proto = octocrab
            .repos("esphome", "esphome")
            .get_content()
            .path("esphome/components/api/api.proto")
            .r#ref(release.tag_name.clone())
            .send()
            .await
            .unwrap();

        if let Some(item) = &api_proto.items.first() {
            let decoded_content = item.decoded_content().unwrap();
            let file_path = protos_dir.join("api.proto");
            fs::write(file_path, decoded_content).unwrap();
            println!("Decoded content written to protos/api.proto");
        } else {
            println!("No content found in the API response.");
        }

        let api_proto_options = octocrab
            .repos("esphome", "esphome")
            .get_content()
            .path("esphome/components/api/api_options.proto")
            .r#ref(release.tag_name.clone())
            .send()
            .await
            .unwrap();

        if let Some(item) = &api_proto_options.items.first() {
            let decoded_content = item.decoded_content().unwrap();
            let file_path = protos_dir.join("api_options.proto");
            fs::write(file_path, decoded_content).unwrap();
            println!("Decoded content written to protos/api.proto");
        } else {
            println!("No content found in the API response.");
        }

        let package_name = get_package_name(&release.tag_name);
        
        versions.push(package_name.clone());
        mod_file_content.push_str(&format!("#[cfg(feature = \"{}\")]\npub mod {};\n", package_name, package_name));
        let write_dir = format!("{}/{}", root_output_dir, package_name);
        let write_protos_dir = Path::new(write_dir.as_str());
        fs::create_dir_all(write_protos_dir).unwrap();
        
        let mut config = prost_build::Config::new();
        // config.skip_debug(&["."]);
        config.default_package_filename(&package_name);
        config.out_dir(write_protos_dir);
        config.include_file("mod.rs");
        config.compile_protos(&[format!("{}/api.proto", dir)], &[dir]).unwrap();
    }
    
    let mod_file = Path::new(root_output_dir).join("mod.rs");
    fs::write(mod_file, mod_file_content).unwrap();

    let mut file = File::open("../Cargo.toml").unwrap();

    let mut buf = Vec::new();
    file.read_to_end(&mut buf).unwrap();
    let content_str = String::from_utf8_lossy(&buf);
    let pos = content_str.find("[features]").unwrap(); 
    println!("Found \"[features]\" at position: {}", pos);
    
    
    let mut file = OpenOptions::new()
    .write(true)
    .open("../Cargo.toml")
    .unwrap();
    file.seek(std::io::SeekFrom::Start(pos.try_into().unwrap())).unwrap();
    file.write(b"[features]\n").unwrap();
    let default_feature_flag = get_package_name(current_version);
    file.write(format!("default = [\"std\", \"{}\"]\n", default_feature_flag).as_bytes()).unwrap();
    file.write(b"std = []\n").unwrap();

    for version in versions {
        file.write(format!("{} = []\n", version).as_bytes()).unwrap();
    }
    let pos = file.stream_position().unwrap();
    file.set_len(pos).unwrap();

}

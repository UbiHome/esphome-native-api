use dotenv::dotenv;
use octocrab::Octocrab;
use std::env;
use std::fs::{self, OpenOptions};
use std::io::{Seek, Write};
use std::path::Path;

const CURRENT_VERSION: &str = "2025.12.1";
const LAST_SUPPLIED_VERSION: &str = "2025.2.1";

fn get_package_name(version: &str) -> String {
    format!("version_{}", version).replace(".", "_")
}

#[tokio::main]
async fn main() {
    dotenv().ok(); // Read the .env file
    let mut octocrab: Octocrab = (*octocrab::instance()).clone();
    if env::var("GITHUB_TOKEN").is_ok() {
        println!("Using token");
        let token = env::var("GITHUB_TOKEN").unwrap();
        octocrab = octocrab.user_access_token(token).unwrap();
    }

    let generator_root_dir = Path::new(env!("CARGO_MANIFEST_DIR"));
    let root_dir = generator_root_dir.join("..");

    let root_output_dir = root_dir.join("src/proto");
    let mut mod_file_content = "// This file is @generated by the generator.\n".to_string();
    let mut versions: Vec<String> = Vec::new();

    let repo = octocrab.repos("esphome", "esphome");

    let mut page_number: u32 = 1;
    'outer: loop {
        println!("Getting release page {}", page_number);

        let page = repo
            .releases()
            .list()
            .per_page(50)
            .page(page_number)
            .send()
            .await
            .unwrap();

        for release in &page {
            print!("{}", &release.tag_name);
            if release.tag_name.contains("b") {
                println!(" => Skipped (reason: beta)");
                continue;
            } else {
                println!(" => Generating");
            }

            let package_version = &release.tag_name;
            let package_name = get_package_name(package_version);
            versions.push(package_name.clone());

            let protos_dir = generator_root_dir.join("protos").join(package_version);
            fs::create_dir_all(&protos_dir).unwrap();

            // Proto file
            let file_path = protos_dir.join("api.proto");
            if !file_path.exists() {
                let api_proto = repo
                    .get_content()
                    .path("esphome/components/api/api.proto")
                    .r#ref(&release.tag_name)
                    .send()
                    .await
                    .unwrap();

                if let Some(item) = &api_proto.items.first() {
                    let decoded_content = item.decoded_content().unwrap();
                    fs::write(file_path, decoded_content).unwrap();
                    println!("Decoded content written to protos/api.proto");
                } else {
                    println!("No content found in the API response.");
                }
            }

            // Proto options file
            let file_path = protos_dir.join("api_options.proto");
            if !file_path.exists() {
                let api_proto_options = repo
                    .get_content()
                    .path("esphome/components/api/api_options.proto")
                    .r#ref(&release.tag_name)
                    .send()
                    .await
                    .unwrap();

                if let Some(item) = &api_proto_options.items.first() {
                    let decoded_content = item.decoded_content().unwrap();
                    fs::write(file_path, decoded_content).unwrap();
                    println!("Decoded content written to protos/api_options.proto");
                } else {
                    println!("No content found in the API response.");
                }
            }

            mod_file_content.push_str(&format!(
                "\n#[cfg(feature = {package_name:?})]\npub mod {package_name};\n#[cfg(feature = {package_name:?})]\npub use {package_name}::*;\n#[cfg(feature = {package_name:?})]\npub(crate) const VERSION: &str = {package_version:?};\n"
            ));

            let write_dir = root_output_dir.join(&package_name);
            fs::create_dir_all(&write_dir).unwrap();

            let mut config = prost_build::Config::new();
            // config.skip_debug(&["."]);
            config.default_package_filename(&package_name);
            config.out_dir(&write_dir);
            config.include_file("mod.rs");
            config
                .compile_protos(&[protos_dir.join("api.proto")], &[protos_dir])
                .unwrap();

            // Only till this release:
            if package_version == LAST_SUPPLIED_VERSION {
                println!("Stopped (hit last supplied version)");
                break 'outer;
            }
        }

        page_number += 1;
    }

    let mod_file = Path::new(&root_output_dir).join("mod.rs");
    fs::write(mod_file, mod_file_content).unwrap();

    let cargo_toml = Path::new(&root_dir)
        .join("Cargo.toml")
        .canonicalize()
        .unwrap();

    let content_str = fs::read_to_string(&cargo_toml).unwrap();
    let pos = content_str.find("[features]").unwrap();
    println!("Found \"[features]\" at position: {}", pos);

    let mut file = OpenOptions::new().write(true).open(&cargo_toml).unwrap();
    file.seek(std::io::SeekFrom::Start(pos.try_into().unwrap()))
        .unwrap();
    writeln!(file, "[features]").unwrap();
    let default_package_name = get_package_name(CURRENT_VERSION);
    writeln!(file, "default = [\"std\", \"{}\"]", default_package_name).unwrap();
    writeln!(file, "std = []").unwrap();

    for version in versions {
        writeln!(file, "{} = []", version).unwrap();
    }
    let pos = file.stream_position().unwrap();
    file.set_len(pos).unwrap();
}
